<div
	ref:container
	class="layout"
	on:mousemove="drag(event)"
	on:mouseup="end(event)"
	on:mouseleave="end(event)"
	style="--spacing: {spacing}"
>
	{#each _panes as pane (pane.id)}
		<Pane {pane} {component} on:split="split(pane, event)"/>
	{/each}

	{#each _dividers as divider (divider.id)}
		<Divider {divider} on:mousedown="set({ _dragging: !event.ctrlKey && !event.metaKey && divider })"/>
	{/each}
</div>

<style>
	.layout {
		position: absolute;
		width: calc(100% + var(--spacing));
		height: calc(100% + var(--spacing));
		overflow: hidden;
		margin: calc(0px - var(--spacing) / 2);
	}
</style>

<script>
	import * as constants from './constants.js';
	import { removeFromArray, clamp } from './utils.js';

	class Rect {
		constructor(x, y, w, h, prev, next) {
			this.x = x;
			this.y = y;
			this.w = w;
			this.h = h;

			this.prev = prev;
			this.next = next;

			this.parent = null;
		}

		bounds(rect) {
			const width = rect.right - rect.left;
			const height = rect.bottom - rect.top;

			return {
				left: rect.left + width * this.getLeft(),
				top: rect.top + height * this.getTop(),
				width: width * this.getWidth(),
				height: height * this.getHeight()
			};
		}

		getLeft() {
			let left = this.x;

			let node = this;
			while (node = node.parent) left = node.x + (node.w * left);

			return left;
		}

		getTop() {
			let top = this.y;

			let node = this;
			while (node = node.parent) top = node.y + (node.h * top);

			return top;
		}

		getWidth() {
			let width = this.w;

			let node = this;
			while (node = node.parent) width *= node.w;

			return width;
		}

		getHeight() {
			let height = this.h;

			let node = this;
			while (node = node.parent) height *= node.h;

			return height;
		}

		setRange(a, b) {
			if (this.parent.type === constants.COLUMN) {
				this.y = a;
				this.h = (b - a);
			} else {
				this.x = a;
				this.w = (b - a);
			}
		}
	}

	class Pane extends Rect {
		constructor(id, { x, y, w, h, prev, next }) {
			super(x, y, w, h, prev, next);
			this.id = id;
		}

		destroy(panes, dividers) {
			const index = panes.indexOf(this);
			if (index === -1) throw new Error(`Unexpected error`);
			panes.splice(index, 1);
		}
	}

	class Group extends Rect {
		constructor(type, { x, y, w, h, prev, next }) {
			super(x, y, w, h, prev, next);

			this.type = type;
			this.children = [];
			this.dividers = [];
		}

		addChild(child) {
			this.children.push(child);
			child.parent = this;
		}

		replaceChild(child, replacement) {
			const index = this.children.indexOf(child);
			if (index === -1) throw new Error(`Unexpected error`);
			this.children[index] = replacement;

			replacement.parent = this;

			child.parent = replacement;
			replacement.children.push(child);
		}

		destroy(panes, dividers) {
			let i = this.children.length;
			while (i--) this.children[i].destroy(panes, dividers);

			i = this.dividers.length;
			while (i--) this.dividers[i].destroy(panes, dividers);
		}
	}

	class Divider {
		constructor({ id, direction, group, position, prev, next }) {
			this.id = id;
			this.direction = direction;
			this.parent = group;
			this.position = position;
			this.prev = prev;
			this.next = next;

			group.dividers.push(this);
		}

		destroy(panes, dividers) {
			const index = dividers.indexOf(this);
			if (index === -1) throw new Error(`Unexpected error`);
			dividers.splice(index, 1);
		}
	}

	export default {
		components: {
			Pane: './Pane.html',
			Divider: './Divider.html'
		},

		data() {
			const root = new Group(constants.COLUMN, {
				x: 0,
				y: 0,
				w: 1,
				h: 1,
				prev: null,
				next: null
			});

			const pane = new Pane(0, {
				x: 0,
				y: 0,
				w: 1,
				h:1,
				prev: null,
				next: null
			});

			root.addChild(pane);

			return {
				spacing: '6px',
				_pid: 1,
				_did: 0,
				_panes: [pane],
				_dividers: []
			};
		},

		methods: {
			split(pane, event) {
				const { left, right, top, bottom } = this.refs.container.getBoundingClientRect();
				let { _pid, _did, _panes, _dividers } = this.get();
				const { edge, clientX, clientY } = event;

				const direction = edge === constants.NORTH || edge === constants.SOUTH
					? constants.HORIZONTAL
					: constants.VERTICAL;

				const type = direction === constants.HORIZONTAL
					? constants.COLUMN
					: constants.ROW;

				let group = pane.parent;

				const newGroup = group && group.type === type
					? null
					: new Group(type, pane);

				if (newGroup) {
					pane.x = pane.y = 0;
					pane.w = pane.h = 1;

					pane.parent.replaceChild(pane, newGroup);
					group = newGroup;

					if (pane.next) pane.next.prev = newGroup;
					if (pane.prev) pane.prev.next = newGroup;

					pane.next = pane.prev = null;
				}

				const bounds = group.bounds(this.refs.container.getBoundingClientRect());

				const newPane = new Pane(_pid++, pane);
				group.addChild(newPane);

				const divider = new Divider({
					id: _did++,
					direction,
					group,
					position: null,
					prev: null,
					next: null
				});

				if (type === constants.COLUMN) {
					const y = (clientY - bounds.top) / bounds.height;
					const d = y - pane.y;

					divider.position = y;

					if (edge === constants.NORTH) {
						newPane.h = d;
						pane.y += y;
						pane.h -= d;
					} else {
						newPane.y = y;
						newPane.h = pane.h - d;
						pane.h  = d;
					}
				} else {
					const x = (clientX - bounds.left) / bounds.width;
					const d = x - pane.x;

					divider.position = x;

					if (edge === constants.WEST) {
						newPane.w = d;
						pane.x += x;
						pane.w -= d;
					} else {
						newPane.x = x;
						newPane.w = pane.w - d;
						pane.w  = d;
					}
				}

				if (edge === constants.NORTH || edge === constants.WEST) {
					pane.prev = divider;
					newPane.next = divider;

					if (pane.prev) pane.prev.next = newPane;

					divider.prev = newPane;
					divider.next = pane;
				} else {
					divider.prev = pane;
					divider.next = newPane;

					if (pane.next) pane.next.prev = newPane;

					pane.next = divider;
					newPane.prev = divider;
				}

				_panes.push(newPane);
				_dividers.push(divider);

				this.set({
					_pid,
					_did,
					_panes,
					_dividers,
					_dragging: divider
				});
			},

			drag(event) {
				const { _panes, _dividers, _dragging } = this.get();
				if (!_dragging) return

				const bounds = _dragging.parent.bounds(this.refs.container.getBoundingClientRect());

				const prev = _dragging.prev;
				const next = _dragging.next;

				let min;
				let max;
				let position;

				if (_dragging.direction === constants.VERTICAL) {
					min = prev.x;
					max = next.x + next.w;
					position = clamp((event.clientX - bounds.left) / bounds.width, min, max);
				} else {
					min = prev.y;
					max = next.y + next.h;
					position = clamp((event.clientY - bounds.top) / bounds.height, min, max);
				}

				prev.setRange(min, position);
				next.setRange(position, max);

				_dragging.position = position;

				this.set({ _panes, _dividers });
			},

			end(event) {
				const { _panes, _dividers, _dragging } = this.get();
				if (!_dragging) return;

				this.drag(event);

				const prevSize = _dragging.direction === constants.VERTICAL
					? _dragging.prev.w
					: _dragging.prev.h;

				const min = Math.min(prevSize, _dragging.direction === constants.VERTICAL
					? _dragging.next.w
					: _dragging.next.h)

				if (min < 0.0001) {
					removeFromArray(_dragging.parent.dividers, _dragging);
					removeFromArray(_dividers, _dragging);

					if (prevSize < 0.0001) {
						const mergedDivider = _dragging.prev.prev;

						_dragging.next.prev = mergedDivider;
						if (mergedDivider) mergedDivider.next = _dragging.next;

						_dragging.prev.destroy(_panes, _dividers);
						if (_dragging.prev.parent) {
							removeFromArray(_dragging.prev.parent.children, _dragging.prev);
						}
					} else {
						const mergedDivider = _dragging.next.next;

						_dragging.prev.next = mergedDivider;
						if (mergedDivider) mergedDivider.prev = _dragging.prev;

						_dragging.next.destroy(_panes, _dividers);
						if (_dragging.next.parent) {
							removeFromArray(_dragging.next.parent.children, _dragging.next);
						}
					}
				}

				this.set({ _panes, _dividers, _dragging: false });
			}
		}
	};
</script>